{"version":3,"sources":["core/gyi.ts"],"names":[],"mappings":"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","file":"../../core/gyi.js","sourcesContent":["import gulp, { dest, parallel, series, src, task } from 'gulp';\nimport { isArray, isFunction, map } from 'lodash';\nimport Undertaker from 'undertaker';\nimport { Gulp } from '../libs';\nimport { GyiLib } from '../libs/gyi.libs';\n\nexport interface GyiStruct {\n\n}\n\nexport type StringStruct = string | Function | Array<string | Function>;\nexport type QueueStruct = Undertaker.TaskFunction | Array<Undertaker.TaskFunction>;\n\nexport interface TaskOption {\n    // The gulp src reg\n    src?: StringStruct | Promise<StringStruct>;\n    // The gulp on output dirname\n    dest?: string | Function | Promise<string | Function>;\n    // Series tasks\n    series?: QueueStruct | Promise<QueueStruct>;\n    // Parallel tasks\n    parallel?: QueueStruct | Promise<QueueStruct>;\n    // A special property of named functions. Used to register the task. \n    // Note: name is not writable; it cannot be set or changed.\n    name?: string;\n    // When attached to a taskFunction creates an alias for the task. \n    // If using characters that aren't allowed in function names, use this property.\n    displayName?: string;\n    // When attached to a taskFunction provides a description to be printed by the command line when listing tasks.\n    description?: string | Promise<string> | Function;\n    // When attached to a taskFunction provides flags to be printed by the command line when listing tasks. \n    // The keys of the object represent the flags and the values are their descriptions.\n    flags?: object;\n}\n\nexport class Gyi implements GyiStruct {\n\n    public _root() {\n        return Gyi;\n    }\n\n    public $tasks!: Array<{ option?: TaskOption; action: Function; name: string; }>;\n\n    constructor() {\n        map(this.$tasks, async tkconf => {\n\n            let action: any = async (done: Function) => {\n\n                let gp: any = gulp;\n                if (tkconf.option) {\n                    if (tkconf.option.src) {\n                        let sc: any = await tkconf.option.src;\n                        if (isArray(sc)) { sc = await Promise.all(map(sc, async (s: any) => await s())); }\n                        if (isFunction(sc)) { sc = await sc(); }\n                        gp = src(sc);\n                    }\n                }\n\n                const props = Reflect.getMetadata('design:paramtypes', this, tkconf.name);\n                const args = map(props, prop => {\n                    if (prop._root && isFunction(prop._root) && prop._root() === Gulp) {\n                        return gp;\n                    }\n\n                    if (prop._root && isFunction(prop._root) && prop._root() === GyiLib) {\n                        return new prop(gp, tkconf.option);\n                    }\n                });\n\n                await tkconf.action.apply(this, args);\n\n                if (tkconf.option) {\n                    if (tkconf.option.dest) {\n                        let dt: any = await tkconf.option.dest;\n                        if (isFunction(dt)) { dt = await dt(); }\n                        const compile = gp.pipe(dest(dt));\n                        await new Promise(r => compile.on('end', r));\n                    }\n                }\n                return done();\n            }\n\n            if (tkconf.option) {\n                const tasks: any[] = [];\n                if (tkconf.option.series) {\n                    let series = await tkconf.option.series;\n                    if (!isArray(series)) { series = [series]; }\n                    tasks.push(...series);\n                    tasks.push(action);\n                } else {\n                    tasks.push(action);\n                }\n\n                action = series(...tasks);\n\n                if (tkconf.option.parallel) {\n                    let parallel = await tkconf.option.parallel;\n                    if (!isArray(parallel)) { parallel = [parallel]; }\n                    tasks.push(...parallel);\n                    tasks.push(action);\n                }\n\n                action = parallel(...tasks);\n\n                if (tkconf.option.name) { action.name = tkconf.name; }\n                if (tkconf.option.displayName) { action.displayName = tkconf.option.displayName; }\n                if (tkconf.option.description) { action.description = tkconf.option.description; }\n                if (tkconf.option.flags) { action.flags = tkconf.option.flags; }\n            }\n\n            task(tkconf.name, action);\n        });\n    }\n}\n\nexport type GyiBootstrap<G> = {\n    new(...args: any[]): G & Gyi;\n} & typeof Gyi;\n"]}