{"version":3,"sources":["decorators/gfile.ts"],"names":[],"mappings":";;;AAAA,kCAAyF;AACzF,mCAA6B;AAC7B,+BAAwE;AACxE,kCAAkC;AAElC,SAAgB,KAAK,CAA2B,MAAS;IACrD,MAAM,KAAK,GAAa,OAAO,CAAC,WAAW,CAAC,eAAQ,EAAE,MAAM,CAAC,SAAS,EAAE,eAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE7F,YAAG,CAAC,KAAK,EAAE,CAAC,MAAM,EAAE,EAAE;QAClB,MAAM,IAAI,GAAiB,OAAO,CAAC,WAAW,CAAC,cAAO,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,SAAS;QAC5F,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QACnE,MAAM,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QACtF,MAAM,OAAO,GAAmB,CAAC,KAAK,EAAC,IAAI,EAAC,EAAE;gBAC1C,MAAM,MAAM,GAAG,YAAG,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;oBAChC,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,KAAK,EAAE,KAAK,oBAAa,EAAE;wBAAE,OAAO,IAAI,CAAC;qBAAE;oBAC9D,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,KAAK,EAAE,KAAK,cAAO,EAAE;wBAAE,OAAO,IAAI,EAAE,EAAE,CAAC;qBAAE;oBAC5D,OAAO,EAAE,CAAC;gBACd,CAAC,CAAC,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;gBAC9E,MAAM,IAAI,EAAE,CAAC;gBACb,OAAO,MAAM,CAAC;YAClB,CAAC,CAAC,CAAC;QACH,IAAI,MAAM,IAAI,QAAQ;YAAE,OAAO,CAAC,OAAO,CAAC,aAAE,CAAC,GAAG,MAAM,EAAE,eAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;aACnE,IAAI,MAAM,IAAI,CAAC,QAAQ;YAAE,OAAO,CAAC,OAAO,CAAC,aAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;aACxD,IAAI,CAAC,MAAM,IAAI,QAAQ;YAAE,OAAO,CAAC,OAAO,CAAC,eAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC;QAC/D,MAAM,IAAI,GAAG,aAAE,CAAC,OAAO,CAAC,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,WAAW,IAAI,MAAM,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,WAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;AACP,CAAC;AAzBD,sBAyBC","file":"../../decorators/gfile.js","sourcesContent":["import { GulpFile, Core, TASKKEY, ITaskOptions, IDoneFunction, TASKSKEY } from '../core';\nimport { map } from 'lodash';\nimport { task, series as ss, parallel as pl, TaskFunction } from 'gulp';\nimport { CoreLib } from '../libs';\n\nexport function GFile<G extends GulpFile<Core>>(target: G) {\n    const tasks: string[] = Reflect.getMetadata(TASKSKEY, target.prototype, TASKSKEY.toString());\n\n    map(tasks, (method) => {\n        const data: ITaskOptions = Reflect.getMetadata(TASKKEY, target.prototype, method); // 获取存的路径\n        const { parallel, series, description, displayName } = data.config;\n        const paramtypes = Reflect.getMetadata('design:paramtypes', target.prototype, method);\n        const actions: TaskFunction[] = [async done => {\n            const params = map(paramtypes, pt => {\n                if (pt._root && pt._root() === IDoneFunction) { return done; }\n                if (pt._root && pt._root() === CoreLib) { return new pt(); }\n                return pt;\n            });\n            const result = await target.prototype[method].apply(target.prototype, params);\n            await done();\n            return result;\n        }];\n        if (series && parallel) actions.unshift(ss(...series, pl(...parallel)));\n        else if (series && !parallel) actions.unshift(ss(...series));\n        else if (!series && parallel) actions.unshift(pl(...parallel));\n        const exec = ss(actions);\n        exec.displayName = displayName || method;\n        exec.description = description;\n        task(data.method, exec);\n    });\n}\n"]}